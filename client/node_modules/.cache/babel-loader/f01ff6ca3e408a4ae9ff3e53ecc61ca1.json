{"ast":null,"code":"'use strict';\n\nconst MiniPass = require('minipass');\n\nconst Pax = require('./pax.js');\n\nconst Header = require('./header.js');\n\nconst fs = require('fs');\n\nconst path = require('path');\n\nconst normPath = require('./normalize-windows-path.js');\n\nconst stripSlash = require('./strip-trailing-slashes.js');\n\nconst prefixPath = (path, prefix) => {\n  if (!prefix) return normPath(path);\n  path = normPath(path).replace(/^\\.(\\/|$)/, '');\n  return stripSlash(prefix) + '/' + path;\n};\n\nconst maxReadSize = 16 * 1024 * 1024;\nconst PROCESS = Symbol('process');\nconst FILE = Symbol('file');\nconst DIRECTORY = Symbol('directory');\nconst SYMLINK = Symbol('symlink');\nconst HARDLINK = Symbol('hardlink');\nconst HEADER = Symbol('header');\nconst READ = Symbol('read');\nconst LSTAT = Symbol('lstat');\nconst ONLSTAT = Symbol('onlstat');\nconst ONREAD = Symbol('onread');\nconst ONREADLINK = Symbol('onreadlink');\nconst OPENFILE = Symbol('openfile');\nconst ONOPENFILE = Symbol('onopenfile');\nconst CLOSE = Symbol('close');\nconst MODE = Symbol('mode');\nconst AWAITDRAIN = Symbol('awaitDrain');\nconst ONDRAIN = Symbol('ondrain');\nconst PREFIX = Symbol('prefix');\nconst HAD_ERROR = Symbol('hadError');\n\nconst warner = require('./warn-mixin.js');\n\nconst winchars = require('./winchars.js');\n\nconst stripAbsolutePath = require('./strip-absolute-path.js');\n\nconst modeFix = require('./mode-fix.js');\n\nconst WriteEntry = warner(class WriteEntry extends MiniPass {\n  constructor(p, opt) {\n    opt = opt || {};\n    super(opt);\n    if (typeof p !== 'string') throw new TypeError('path is required');\n    this.path = normPath(p); // suppress atime, ctime, uid, gid, uname, gname\n\n    this.portable = !!opt.portable; // until node has builtin pwnam functions, this'll have to do\n\n    this.myuid = process.getuid && process.getuid() || 0;\n    this.myuser = process.env.USER || '';\n    this.maxReadSize = opt.maxReadSize || maxReadSize;\n    this.linkCache = opt.linkCache || new Map();\n    this.statCache = opt.statCache || new Map();\n    this.preservePaths = !!opt.preservePaths;\n    this.cwd = normPath(opt.cwd || process.cwd());\n    this.strict = !!opt.strict;\n    this.noPax = !!opt.noPax;\n    this.noMtime = !!opt.noMtime;\n    this.mtime = opt.mtime || null;\n    this.prefix = opt.prefix ? normPath(opt.prefix) : null;\n    this.fd = null;\n    this.blockLen = null;\n    this.blockRemain = null;\n    this.buf = null;\n    this.offset = null;\n    this.length = null;\n    this.pos = null;\n    this.remain = null;\n    if (typeof opt.onwarn === 'function') this.on('warn', opt.onwarn);\n    let pathWarn = false;\n\n    if (!this.preservePaths) {\n      const [root, stripped] = stripAbsolutePath(this.path);\n\n      if (root) {\n        this.path = stripped;\n        pathWarn = root;\n      }\n    }\n\n    this.win32 = !!opt.win32 || process.platform === 'win32';\n\n    if (this.win32) {\n      // force the \\ to / normalization, since we might not *actually*\n      // be on windows, but want \\ to be considered a path separator.\n      this.path = winchars.decode(this.path.replace(/\\\\/g, '/'));\n      p = p.replace(/\\\\/g, '/');\n    }\n\n    this.absolute = normPath(opt.absolute || path.resolve(this.cwd, p));\n    if (this.path === '') this.path = './';\n\n    if (pathWarn) {\n      this.warn('TAR_ENTRY_INFO', `stripping ${pathWarn} from absolute path`, {\n        entry: this,\n        path: pathWarn + this.path\n      });\n    }\n\n    if (this.statCache.has(this.absolute)) this[ONLSTAT](this.statCache.get(this.absolute));else this[LSTAT]();\n  }\n\n  emit(ev) {\n    if (ev === 'error') this[HAD_ERROR] = true;\n\n    for (var _len = arguments.length, data = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      data[_key - 1] = arguments[_key];\n    }\n\n    return super.emit(ev, ...data);\n  }\n\n  [LSTAT]() {\n    fs.lstat(this.absolute, (er, stat) => {\n      if (er) return this.emit('error', er);\n      this[ONLSTAT](stat);\n    });\n  }\n\n  [ONLSTAT](stat) {\n    this.statCache.set(this.absolute, stat);\n    this.stat = stat;\n    if (!stat.isFile()) stat.size = 0;\n    this.type = getType(stat);\n    this.emit('stat', stat);\n    this[PROCESS]();\n  }\n\n  [PROCESS]() {\n    switch (this.type) {\n      case 'File':\n        return this[FILE]();\n\n      case 'Directory':\n        return this[DIRECTORY]();\n\n      case 'SymbolicLink':\n        return this[SYMLINK]();\n      // unsupported types are ignored.\n\n      default:\n        return this.end();\n    }\n  }\n\n  [MODE](mode) {\n    return modeFix(mode, this.type === 'Directory', this.portable);\n  }\n\n  [PREFIX](path) {\n    return prefixPath(path, this.prefix);\n  }\n\n  [HEADER]() {\n    if (this.type === 'Directory' && this.portable) this.noMtime = true;\n    this.header = new Header({\n      path: this[PREFIX](this.path),\n      // only apply the prefix to hard links.\n      linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath) : this.linkpath,\n      // only the permissions and setuid/setgid/sticky bitflags\n      // not the higher-order bits that specify file type\n      mode: this[MODE](this.stat.mode),\n      uid: this.portable ? null : this.stat.uid,\n      gid: this.portable ? null : this.stat.gid,\n      size: this.stat.size,\n      mtime: this.noMtime ? null : this.mtime || this.stat.mtime,\n      type: this.type,\n      uname: this.portable ? null : this.stat.uid === this.myuid ? this.myuser : '',\n      atime: this.portable ? null : this.stat.atime,\n      ctime: this.portable ? null : this.stat.ctime\n    });\n\n    if (this.header.encode() && !this.noPax) {\n      super.write(new Pax({\n        atime: this.portable ? null : this.header.atime,\n        ctime: this.portable ? null : this.header.ctime,\n        gid: this.portable ? null : this.header.gid,\n        mtime: this.noMtime ? null : this.mtime || this.header.mtime,\n        path: this[PREFIX](this.path),\n        linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath) : this.linkpath,\n        size: this.header.size,\n        uid: this.portable ? null : this.header.uid,\n        uname: this.portable ? null : this.header.uname,\n        dev: this.portable ? null : this.stat.dev,\n        ino: this.portable ? null : this.stat.ino,\n        nlink: this.portable ? null : this.stat.nlink\n      }).encode());\n    }\n\n    super.write(this.header.block);\n  }\n\n  [DIRECTORY]() {\n    if (this.path.substr(-1) !== '/') this.path += '/';\n    this.stat.size = 0;\n    this[HEADER]();\n    this.end();\n  }\n\n  [SYMLINK]() {\n    fs.readlink(this.absolute, (er, linkpath) => {\n      if (er) return this.emit('error', er);\n      this[ONREADLINK](linkpath);\n    });\n  }\n\n  [ONREADLINK](linkpath) {\n    this.linkpath = normPath(linkpath);\n    this[HEADER]();\n    this.end();\n  }\n\n  [HARDLINK](linkpath) {\n    this.type = 'Link';\n    this.linkpath = normPath(path.relative(this.cwd, linkpath));\n    this.stat.size = 0;\n    this[HEADER]();\n    this.end();\n  }\n\n  [FILE]() {\n    if (this.stat.nlink > 1) {\n      const linkKey = this.stat.dev + ':' + this.stat.ino;\n\n      if (this.linkCache.has(linkKey)) {\n        const linkpath = this.linkCache.get(linkKey);\n        if (linkpath.indexOf(this.cwd) === 0) return this[HARDLINK](linkpath);\n      }\n\n      this.linkCache.set(linkKey, this.absolute);\n    }\n\n    this[HEADER]();\n    if (this.stat.size === 0) return this.end();\n    this[OPENFILE]();\n  }\n\n  [OPENFILE]() {\n    fs.open(this.absolute, 'r', (er, fd) => {\n      if (er) return this.emit('error', er);\n      this[ONOPENFILE](fd);\n    });\n  }\n\n  [ONOPENFILE](fd) {\n    this.fd = fd;\n    if (this[HAD_ERROR]) return this[CLOSE]();\n    this.blockLen = 512 * Math.ceil(this.stat.size / 512);\n    this.blockRemain = this.blockLen;\n    const bufLen = Math.min(this.blockLen, this.maxReadSize);\n    this.buf = Buffer.allocUnsafe(bufLen);\n    this.offset = 0;\n    this.pos = 0;\n    this.remain = this.stat.size;\n    this.length = this.buf.length;\n    this[READ]();\n  }\n\n  [READ]() {\n    const {\n      fd,\n      buf,\n      offset,\n      length,\n      pos\n    } = this;\n    fs.read(fd, buf, offset, length, pos, (er, bytesRead) => {\n      if (er) {\n        // ignoring the error from close(2) is a bad practice, but at\n        // this point we already have an error, don't need another one\n        return this[CLOSE](() => this.emit('error', er));\n      }\n\n      this[ONREAD](bytesRead);\n    });\n  }\n\n  [CLOSE](cb) {\n    fs.close(this.fd, cb);\n  }\n\n  [ONREAD](bytesRead) {\n    if (bytesRead <= 0 && this.remain > 0) {\n      const er = new Error('encountered unexpected EOF');\n      er.path = this.absolute;\n      er.syscall = 'read';\n      er.code = 'EOF';\n      return this[CLOSE](() => this.emit('error', er));\n    }\n\n    if (bytesRead > this.remain) {\n      const er = new Error('did not encounter expected EOF');\n      er.path = this.absolute;\n      er.syscall = 'read';\n      er.code = 'EOF';\n      return this[CLOSE](() => this.emit('error', er));\n    } // null out the rest of the buffer, if we could fit the block padding\n    // at the end of this loop, we've incremented bytesRead and this.remain\n    // to be incremented up to the blockRemain level, as if we had expected\n    // to get a null-padded file, and read it until the end.  then we will\n    // decrement both remain and blockRemain by bytesRead, and know that we\n    // reached the expected EOF, without any null buffer to append.\n\n\n    if (bytesRead === this.remain) {\n      for (let i = bytesRead; i < this.length && bytesRead < this.blockRemain; i++) {\n        this.buf[i + this.offset] = 0;\n        bytesRead++;\n        this.remain++;\n      }\n    }\n\n    const writeBuf = this.offset === 0 && bytesRead === this.buf.length ? this.buf : this.buf.slice(this.offset, this.offset + bytesRead);\n    const flushed = this.write(writeBuf);\n    if (!flushed) this[AWAITDRAIN](() => this[ONDRAIN]());else this[ONDRAIN]();\n  }\n\n  [AWAITDRAIN](cb) {\n    this.once('drain', cb);\n  }\n\n  write(writeBuf) {\n    if (this.blockRemain < writeBuf.length) {\n      const er = new Error('writing more data than expected');\n      er.path = this.absolute;\n      return this.emit('error', er);\n    }\n\n    this.remain -= writeBuf.length;\n    this.blockRemain -= writeBuf.length;\n    this.pos += writeBuf.length;\n    this.offset += writeBuf.length;\n    return super.write(writeBuf);\n  }\n\n  [ONDRAIN]() {\n    if (!this.remain) {\n      if (this.blockRemain) super.write(Buffer.alloc(this.blockRemain));\n      return this[CLOSE](er => er ? this.emit('error', er) : this.end());\n    }\n\n    if (this.offset >= this.length) {\n      // if we only have a smaller bit left to read, alloc a smaller buffer\n      // otherwise, keep it the same length it was before.\n      this.buf = Buffer.allocUnsafe(Math.min(this.blockRemain, this.buf.length));\n      this.offset = 0;\n    }\n\n    this.length = this.buf.length - this.offset;\n    this[READ]();\n  }\n\n});\n\nclass WriteEntrySync extends WriteEntry {\n  [LSTAT]() {\n    this[ONLSTAT](fs.lstatSync(this.absolute));\n  }\n\n  [SYMLINK]() {\n    this[ONREADLINK](fs.readlinkSync(this.absolute));\n  }\n\n  [OPENFILE]() {\n    this[ONOPENFILE](fs.openSync(this.absolute, 'r'));\n  }\n\n  [READ]() {\n    let threw = true;\n\n    try {\n      const {\n        fd,\n        buf,\n        offset,\n        length,\n        pos\n      } = this;\n      const bytesRead = fs.readSync(fd, buf, offset, length, pos);\n      this[ONREAD](bytesRead);\n      threw = false;\n    } finally {\n      // ignoring the error from close(2) is a bad practice, but at\n      // this point we already have an error, don't need another one\n      if (threw) {\n        try {\n          this[CLOSE](() => {});\n        } catch (er) {}\n      }\n    }\n  }\n\n  [AWAITDRAIN](cb) {\n    cb();\n  }\n\n  [CLOSE](cb) {\n    fs.closeSync(this.fd);\n    cb();\n  }\n\n}\n\nconst WriteEntryTar = warner(class WriteEntryTar extends MiniPass {\n  constructor(readEntry, opt) {\n    opt = opt || {};\n    super(opt);\n    this.preservePaths = !!opt.preservePaths;\n    this.portable = !!opt.portable;\n    this.strict = !!opt.strict;\n    this.noPax = !!opt.noPax;\n    this.noMtime = !!opt.noMtime;\n    this.readEntry = readEntry;\n    this.type = readEntry.type;\n    if (this.type === 'Directory' && this.portable) this.noMtime = true;\n    this.prefix = opt.prefix || null;\n    this.path = normPath(readEntry.path);\n    this.mode = this[MODE](readEntry.mode);\n    this.uid = this.portable ? null : readEntry.uid;\n    this.gid = this.portable ? null : readEntry.gid;\n    this.uname = this.portable ? null : readEntry.uname;\n    this.gname = this.portable ? null : readEntry.gname;\n    this.size = readEntry.size;\n    this.mtime = this.noMtime ? null : opt.mtime || readEntry.mtime;\n    this.atime = this.portable ? null : readEntry.atime;\n    this.ctime = this.portable ? null : readEntry.ctime;\n    this.linkpath = normPath(readEntry.linkpath);\n    if (typeof opt.onwarn === 'function') this.on('warn', opt.onwarn);\n    let pathWarn = false;\n\n    if (!this.preservePaths) {\n      const [root, stripped] = stripAbsolutePath(this.path);\n\n      if (root) {\n        this.path = stripped;\n        pathWarn = root;\n      }\n    }\n\n    this.remain = readEntry.size;\n    this.blockRemain = readEntry.startBlockSize;\n    this.header = new Header({\n      path: this[PREFIX](this.path),\n      linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath) : this.linkpath,\n      // only the permissions and setuid/setgid/sticky bitflags\n      // not the higher-order bits that specify file type\n      mode: this.mode,\n      uid: this.portable ? null : this.uid,\n      gid: this.portable ? null : this.gid,\n      size: this.size,\n      mtime: this.noMtime ? null : this.mtime,\n      type: this.type,\n      uname: this.portable ? null : this.uname,\n      atime: this.portable ? null : this.atime,\n      ctime: this.portable ? null : this.ctime\n    });\n\n    if (pathWarn) {\n      this.warn('TAR_ENTRY_INFO', `stripping ${pathWarn} from absolute path`, {\n        entry: this,\n        path: pathWarn + this.path\n      });\n    }\n\n    if (this.header.encode() && !this.noPax) {\n      super.write(new Pax({\n        atime: this.portable ? null : this.atime,\n        ctime: this.portable ? null : this.ctime,\n        gid: this.portable ? null : this.gid,\n        mtime: this.noMtime ? null : this.mtime,\n        path: this[PREFIX](this.path),\n        linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath) : this.linkpath,\n        size: this.size,\n        uid: this.portable ? null : this.uid,\n        uname: this.portable ? null : this.uname,\n        dev: this.portable ? null : this.readEntry.dev,\n        ino: this.portable ? null : this.readEntry.ino,\n        nlink: this.portable ? null : this.readEntry.nlink\n      }).encode());\n    }\n\n    super.write(this.header.block);\n    readEntry.pipe(this);\n  }\n\n  [PREFIX](path) {\n    return prefixPath(path, this.prefix);\n  }\n\n  [MODE](mode) {\n    return modeFix(mode, this.type === 'Directory', this.portable);\n  }\n\n  write(data) {\n    const writeLen = data.length;\n    if (writeLen > this.blockRemain) throw new Error('writing more to entry than is appropriate');\n    this.blockRemain -= writeLen;\n    return super.write(data);\n  }\n\n  end() {\n    if (this.blockRemain) super.write(Buffer.alloc(this.blockRemain));\n    return super.end();\n  }\n\n});\nWriteEntry.Sync = WriteEntrySync;\nWriteEntry.Tar = WriteEntryTar;\n\nconst getType = stat => stat.isFile() ? 'File' : stat.isDirectory() ? 'Directory' : stat.isSymbolicLink() ? 'SymbolicLink' : 'Unsupported';\n\nmodule.exports = WriteEntry;","map":null,"metadata":{},"sourceType":"script"}